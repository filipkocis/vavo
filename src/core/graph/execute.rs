use wgpu::RenderPass;

use crate::{core::graph::NodeColorTarget, system::SystemsContext, ecs::entities::Entities};

use super::{data::{ColorTargetData, DepthTargetData}, GraphNode, NodeDepthTarget, RenderGraph};

/// Same as `RenderGraphContext`, but without a render_pass, used for custom render systems.
/// It provides preprocessed color and depth targets.
///
/// # Note
/// When implementing custom render systems, you should be careful with the lifetimes and raw
/// pointer usage.
pub struct CustomRenderGraphContext {
    /// Lifetime is tied to graph
    pub node: *mut GraphNode,
    /// Graph containing the node
    pub graph: *const RenderGraph,
    /// Lifetime is tied to the node
    pub color_target: Option<*const wgpu::TextureView>,
    /// Lifetime is tied to the node
    pub depth_target: Option<*const wgpu::TextureView>
}

pub struct RenderGraphContext<'a, 'b> {
    /// Current render pass, should be used to issue draw calls etc.
    pub pass: &'b mut RenderPass<'a>,
    /// Unsafe raw pointer to the node currently being executed, should not be used or modified unless you are sure what
    /// you are doing.
    pub node: *mut GraphNode,
    /// Unsafe raw pointer to render graph from which this context was derived, should not be used or modified unless you are sure what
    /// you are doing.
    pub graph: *mut RenderGraph,
}

impl<'a, 'b> RenderGraphContext<'a, 'b> {
    pub fn new(pass: &'b mut RenderPass<'a>, node: *mut GraphNode, graph: *mut RenderGraph) -> Self {
        Self {
            pass,
            node,
            graph,
        }
    }
}

impl RenderGraph {
    pub(crate) fn execute(&mut self, ctx: &mut SystemsContext, entities: &mut Entities) {
        let self_raw = self as *mut _;
        let sorted = self.sorted.iter().map(|n| unsafe { &mut **n });

        for node in sorted {
            if node.data.needs_regen {
                node.generate_data(ctx);
            }

            // SAFETY: Since encoder is derived from ctx, we just bypass the borrow checker
            let encoder = unsafe { &mut *ctx.renderer.encoder().inner };
            
            let node_raw = node as *mut GraphNode;
            let color_attachment = self.get_color_attachment(node, ctx);
            let depth_attachment = self.get_depth_attachment(node);

            if node.custom_system.is_some() {
                let graph_ctx = CustomRenderGraphContext {
                    node: node_raw,
                    graph: self,
                    color_target: color_attachment.as_ref().map(|x| x.view as *const _),
                    depth_target: depth_attachment.as_ref().map(|x| x.view as *const _),
                };
                
                node.custom_system.as_mut().unwrap().run(graph_ctx, ctx, entities);
                continue;
            }

            let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some(&format!("{} render pass", node.name)),
                color_attachments: &vec![color_attachment].into_iter().filter(|x| x.is_some()).collect::<Vec<_>>(),
                depth_stencil_attachment: depth_attachment,
                occlusion_query_set: None,
                timestamp_writes: None,
            });

            render_pass.set_pipeline(node.data.pipeline.as_ref().expect("Pipeline should have been generated by now").render_pipeline());

            let graph_ctx = RenderGraphContext::new(&mut render_pass, node_raw, self_raw);

            node.system.run(graph_ctx, ctx, entities);
        }
    }

    fn get_color_attachment<'a>(&self, node: &'a GraphNode, ctx: &'a mut SystemsContext) -> Option<wgpu::RenderPassColorAttachment<'a>> {
        let view = match node.data.color_target {
            Some(ref target_data) => {
                match target_data {
                    ColorTargetData::Texture(texture) => &texture.view,
                    ColorTargetData::RAE(rae) => &rae.view,
                }
            },
            None => {
                match &node.color_target {
                    NodeColorTarget::None => return None,
                    NodeColorTarget::Surface => ctx.renderer.view(),
                    NodeColorTarget::Node(name) => {
                        let graph = self as *const RenderGraph;
                        let graph = unsafe { &*graph };

                        let target_node = graph.get(name).unwrap_or_else(|| panic!("Node '{}' not found, but it is a color target for '{}'", name, node.name));
                        let mut color_attachment = self.get_color_attachment(target_node, ctx)
                            .unwrap_or_else(|| panic!("Node '{}' has no color attachment, but it is a color target for '{}'", name, node.name));

                        color_attachment.ops = node.color_ops;
                        return Some(color_attachment) 
                    },
                    target => panic!("'{}' reached unexpected branch, it should have been generated and handled in NodeData", target)
                }
            }
        };

        Some(wgpu::RenderPassColorAttachment {
            view,
            resolve_target: None,
            ops: node.color_ops,
        })
    }

    fn get_depth_attachment<'a>(&self, node: &'a GraphNode) -> Option<wgpu::RenderPassDepthStencilAttachment<'a>> {
        let view = match node.data.depth_target {
            Some(ref target_data) => {
                match target_data {
                    DepthTargetData::Texture(texture) => &texture.view,
                    DepthTargetData::RAE(rae) => &rae.view,
                }
            },
            None => {
                match &node.depth_target {
                    NodeDepthTarget::None => return None,
                    NodeDepthTarget::Node(name) => {
                        let graph = self as *const RenderGraph;
                        let graph = unsafe { &*graph };

                        let target_node = graph.get(name).unwrap_or_else(|| panic!("Node '{}' not found, but it is a color target for '{}'", name, node.name));
                        let mut depth_attachment = self.get_depth_attachment(target_node)
                            .unwrap_or_else(|| panic!("Node '{}' has no color attachment, but it is a color target for '{}'", name, node.name));

                        depth_attachment.depth_ops = node.depth_ops;
                        return Some(depth_attachment)
                        
                    },
                    target => panic!("'{}' reached unexpected branch, it should have been generated and handled in NodeData", target)
                }
            }
        };

        Some(wgpu::RenderPassDepthStencilAttachment {
            view,
            depth_ops: node.depth_ops,
            stencil_ops: None,
        })
    }
}
