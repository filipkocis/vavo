use wgpu::RenderPass;

use crate::{
    assets::ShaderLoader,
    core::graph::NodeColorTarget,
    prelude::World,
    renderer::newtype::{RenderCommandEncoder, RenderDevice, RenderSurfaceTextureView},
};

use super::{
    GraphNode, NodeDepthTarget, RenderGraph,
    data::{ColorTargetData, DepthTargetData},
};

/// Extremely unsafe version of old `RenderGraphContext`, temporary solution for render systems.
/// This data is stored in resources. TODO: refactor the whole render graph execution system
///
/// # Safety
/// NOT SAFE AT ALL, use with extreme caution!
///
/// In custom render systems, valid fields are:
/// - `node` - pointer to the current node
/// - `color_target` - pointer to the color target view, if any
/// - `depth_target` - pointer to the depth target view, if any
///
/// In standard render systems, valid fields are:
/// - `pass` - pointer to the current render pass
/// - `node` - pointer to the current node
#[derive(Default, Clone, crate::macros::Resource)]
pub struct RenderContext {
    /// Current render pass, should be used to issue draw calls etc.
    pub pass: *mut RenderPass<'static>,
    /// Lifetime is tied to graph
    pub node: *mut GraphNode,
    /// Lifetime is tied to the node
    pub color_target: Option<*const wgpu::TextureView>,
    /// Lifetime is tied to the node
    pub depth_target: Option<*const wgpu::TextureView>,
}
// # Safety
// As unsafe as it gets
unsafe impl Send for RenderContext {}
unsafe impl Sync for RenderContext {}

impl RenderContext {
    #[inline]
    pub fn update_custom(
        &mut self,
        node: *mut GraphNode,
        color_target: Option<*const wgpu::TextureView>,
        depth_target: Option<*const wgpu::TextureView>,
    ) {
        self.node = node;
        self.color_target = color_target;
        self.depth_target = depth_target;
    }

    #[inline]
    pub fn update_standard(&mut self, pass: *mut RenderPass<'static>, node: *mut GraphNode) {
        self.pass = pass;
        self.node = node;
        self.color_target = None;
        self.depth_target = None;
    }
}

impl RenderGraph {
    pub(crate) fn execute(&mut self, world: &mut World) {
        let sorted = self.sorted.iter().map(|n| unsafe { &mut **n });

        let device = world.resources.get::<RenderDevice>();
        let mut shader_loader = world.resources.get_mut::<ShaderLoader>();
        let surface_texture_view = world.resources.get::<RenderSurfaceTextureView>();

        if !world.resources.contains::<RenderContext>() {
            world.resources.insert(RenderContext::default())
        }
        let mut render_context = world.resources.get_mut::<RenderContext>();

        for node in sorted {
            if node.data.needs_regen {
                node.generate_data(world, &device, &mut shader_loader);
            }

            let node_raw = node as *mut GraphNode;
            let color_attachment = self.get_color_attachment(node, &surface_texture_view);
            let depth_attachment = self.get_depth_attachment(node);

            if node.custom_system.is_some() {
                render_context.update_custom(
                    node_raw,
                    color_attachment.as_ref().map(|x| x.view as *const _),
                    depth_attachment.as_ref().map(|x| x.view as *const _),
                );

                let custom_system = node.custom_system.as_mut().unwrap();
                custom_system.run(world);
                custom_system.apply(world);
                continue;
            }

            let mut encoder = RenderCommandEncoder::new(&device, node.name.as_str());
            let encoder = unsafe { &mut *(&mut encoder as *mut RenderCommandEncoder) };
            let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some(&format!("{} render pass", node.name)),
                color_attachments: &[color_attachment]
                    .into_iter()
                    .filter(|x| x.is_some())
                    .collect::<Vec<_>>(),
                depth_stencil_attachment: depth_attachment,
                occlusion_query_set: None,
                timestamp_writes: None,
            });

            render_pass.set_pipeline(
                node.data
                    .pipeline
                    .as_ref()
                    .expect("Pipeline should have been generated by now")
                    .render_pipeline(),
            );

            render_context.update_standard(&mut render_pass, node_raw);
            node.system.run(world);
            node.system.apply(world);
        }
    }

    fn get_color_attachment<'a>(
        &self,
        node: &'a GraphNode,
        surface_texture_view: &'a RenderSurfaceTextureView,
    ) -> Option<wgpu::RenderPassColorAttachment<'a>> {
        let view = match node.data.color_target {
            Some(ref target_data) => match target_data {
                ColorTargetData::Texture(texture) => &texture.view,
                ColorTargetData::RAE(rae) => &rae.view,
            },
            None => match &node.color_target {
                NodeColorTarget::None => return None,
                NodeColorTarget::Surface => surface_texture_view,
                NodeColorTarget::Node(name) => {
                    let graph = self as *const RenderGraph;
                    let graph = unsafe { &*graph };

                    let target_node = graph.get(name).unwrap_or_else(|| {
                        panic!(
                            "Node '{}' not found, but it is a color target for '{}'",
                            name, node.name
                        )
                    });
                    let mut color_attachment = self.get_color_attachment(target_node, surface_texture_view)
                            .unwrap_or_else(|| panic!("Node '{}' has no color attachment, but it is a color target for '{}'", name, node.name));

                    color_attachment.ops = node.color_ops;
                    return Some(color_attachment);
                }
                target => panic!(
                    "'{}' reached unexpected branch, it should have been generated and handled in NodeData",
                    target
                ),
            },
        };

        Some(wgpu::RenderPassColorAttachment {
            view,
            depth_slice: None,
            resolve_target: None,
            ops: node.color_ops,
        })
    }

    fn get_depth_attachment<'a>(
        &self,
        node: &'a GraphNode,
    ) -> Option<wgpu::RenderPassDepthStencilAttachment<'a>> {
        let view = match node.data.depth_target {
            Some(ref target_data) => match target_data {
                DepthTargetData::Texture(texture) => &texture.view,
                DepthTargetData::RAE(rae) => &rae.view,
            },
            None => match &node.depth_target {
                NodeDepthTarget::None => return None,
                NodeDepthTarget::Node(name) => {
                    let graph = self as *const RenderGraph;
                    let graph = unsafe { &*graph };

                    let target_node = graph.get(name).unwrap_or_else(|| {
                        panic!(
                            "Node '{}' not found, but it is a color target for '{}'",
                            name, node.name
                        )
                    });
                    let mut depth_attachment = self.get_depth_attachment(target_node)
                            .unwrap_or_else(|| panic!("Node '{}' has no color attachment, but it is a color target for '{}'", name, node.name));

                    depth_attachment.depth_ops = node.depth_ops;
                    return Some(depth_attachment);
                }
                target => panic!(
                    "'{}' reached unexpected branch, it should have been generated and handled in NodeData",
                    target
                ),
            },
        };

        Some(wgpu::RenderPassDepthStencilAttachment {
            view,
            depth_ops: node.depth_ops,
            stencil_ops: None,
        })
    }
}
