use glam::{Mat4, Vec4Swizzles};
use pipeline::PipelineBuilder;

use crate::{core::{graph::*, lighting::LightAndShadowManager}, math::CubeFace, prelude::*, render_assets::*, system::CustomGraphSystem};

pub fn standard_shadow_node(ctx: &mut SystemsContext) -> GraphNode {
    // Create pipeline builder
    let shadow_pipeline_builder = create_shadow_pipeline_builder(ctx.renderer.device());

    // Create light and shadow manager
    let manager = LightAndShadowManager::new(ctx);
    ctx.resources.insert(manager);
    
    // Create graph node
    GraphNodeBuilder::new("shadow")
        .set_pipeline(shadow_pipeline_builder)
        .set_custom_system(CustomGraphSystem::new("shadow_render_system", shadow_render_system))
        // TODO: fix loop dependency
        // .add_dependency("main")
        .build()
}

fn shadow_render_system<'a>(
    graph_ctx: CustomRenderGraphContext, 
    ctx: &mut SystemsContext, 
    mut query: Query<'a, (&'a Handle<Material>, &'a Handle<Mesh>, &'a GlobalTransform)>
) {
    // Render assets
    let mut buffers = ctx.resources.get_mut::<RenderAssets<Buffer>>().unwrap();

    // Extract camera position
    let mut camera_query = query.cast::<(&GlobalTransform, &Camera), (With<Projection>, With<Camera3D>)>(); 
    let active_camera = camera_query.iter_mut().into_iter().filter(|(_, c)| c.active).take(1).next();
    let camera_position = match active_camera.map(|(t, _)| t.matrix.w_axis.xyz()) {
        Some(p) => p,
        None => return
    };

    // Prepare sorted storage
    let materials = ctx.resources.get::<Assets<Material>>().unwrap();
    let mut transforms = Vec::new();
    let mut sorted = Vec::<(&Handle<Mesh>, &GlobalTransform)>::new();
    for (mat, mesh, global_transform) in query.iter_mut() {
        if materials.get(mat).expect("Material not found").unlit {
            continue;
        }

        sorted.push((mesh, global_transform));
    }

    // Sort by mesh
    sorted.sort_by(|a, b| a.0.id().cmp(&b.0.id()));

    // Group by mesh
    let last_index = sorted.len() - 1;
    let mut last_entry = None;
    let mut instance_count = 0;
    let mut instance_offset = 0;
    let mut grouped = Vec::<(&Handle<Mesh>, u32, u32)>::new();
    for (i, (mesh, global_transform)) in sorted.into_iter().enumerate() {
        if let Some((last_mesh, last_instance_count)) = last_entry {
            if last_mesh == mesh {
                instance_count += 1;
            } else {
                grouped.push((last_mesh, last_instance_count, instance_offset));
                instance_offset += last_instance_count;
                instance_count = 1;
            }
        } else {
            instance_count = 1;
        }

        if i == last_index {
            grouped.push((mesh, instance_count, instance_offset));
        }

        last_entry = Some((mesh, instance_count));
        transforms.push(global_transform.as_matrix().to_cols_array_2d());
    }

    // Set transforms storage
    let mut transforms_storage = ctx.resources.get_mut::<TransformStorage>().unwrap();
    // TODO: do not update this -> WaW
    transforms_storage.update(&transforms, transforms.len(), ctx);

    // Prepare light data
    let mut light_data = prepare_light_data(camera_position, ctx, query.cast());

    // Set lights storage
    let mut light_manager = ctx.resources.get_mut::<LightAndShadowManager>().unwrap();
    light_manager.update(&mut light_data, ctx);

    // Get node's pipeline
    let pipeline = unsafe { &*graph_ctx.node }.data.pipeline.as_ref().expect("Pipeline should have been generated by now").render_pipeline();

    // Instanced per light
    for i in 0..light_data.len() {
        let light = &light_data[i];

        if light.is_ambient() || !light.is_shadowed() || !light.is_visible() {
            continue;
        }

        per_light_render_pass(i as u32, &light, &grouped, &transforms_storage, &light_manager, pipeline, &mut buffers, ctx);
    }
}

fn per_light_render_pass(
    light_index: u32,
    light: &Light,
    grouped: &[(&Handle<Mesh>, u32, u32)], 
    transforms_storage: &TransformStorage,
    light_manager: &LightAndShadowManager,
    pipeline: &wgpu::RenderPipeline,
    buffers: &mut RenderAssets<Buffer>, 
    ctx: &mut SystemsContext,
) {
    // Create render pass with the correct layer in the shadow map
    let encoder = ctx.renderer.encoder().inner;
    let mut render_pass = unsafe { &mut *encoder }.begin_render_pass(&wgpu::RenderPassDescriptor {
        label: Some("shadow render pass"),
        color_attachments: &[],
        depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
            view: &light_manager.create_view(light),
            depth_ops: Some(wgpu::Operations {
                load: wgpu::LoadOp::Clear(1.0),
                store: wgpu::StoreOp::Store,
            }),
            stencil_ops: None,
        }),
        occlusion_query_set: None,
        timestamp_writes: None,
    });

    // Set pipeline
    render_pass.set_pipeline(pipeline);

    // Set bind groups for transforms and lights
    render_pass.set_bind_group(0, transforms_storage.bind_group(), &[]);
    render_pass.set_bind_group(1, light_manager.storage.bind_group(), &[]);

    // Set light index
    render_pass.set_push_constants(wgpu::ShaderStages::VERTEX, 0, bytemuck::bytes_of(&light_index));
    
    // Instanced draw loop
    let mut last_mesh = None;
    for (mesh, instance_count, instance_offset) in grouped {
        // set vertex buffer with mesh
        let mesh_buffer = buffers.get_by_handle(mesh, ctx); 
        if last_mesh != Some(*mesh) {
            render_pass.set_vertex_buffer(0, mesh_buffer.vertex.as_ref()
                .expect("mesh should have vertex buffer").slice(..));
        }

        // draw
        let instance_range = *instance_offset..(*instance_offset + *instance_count);
        if let Some(index_buffer) = &mesh_buffer.index {
            render_pass.set_index_buffer(index_buffer.slice(..), wgpu::IndexFormat::Uint32);
            render_pass.draw_indexed(0..mesh_buffer.num_indices, 0, instance_range);
        } else {
            render_pass.draw(0..mesh_buffer.num_vertices, instance_range);
        }

        last_mesh = Some(*mesh);
    }
}

fn prepare_light_data(camera_position: glam::Vec3, ctx: &mut SystemsContext, mut query: Query<()>) -> Vec<Light> {
    let mut light_data = Vec::new();

    // directional lights
    let mut directional_query = query.cast::<(&GlobalTransform, &DirectionalLight), ()>();
    for (global_transform, light) in directional_query.iter_mut() {
        let (view_projection_matrix, direction) = light.view_projection_matrix(50.0, 0.1, 50.0, camera_position, global_transform.matrix);

        light_data.push(light
            .as_light(view_projection_matrix)
            .with_directional(direction)
        )
    }

    // spot lights
    let mut spot_query = query.cast::<(&GlobalTransform, &SpotLight), ()>();
    for (global_transform, light) in spot_query.iter_mut() {
        let (view_projection_matrix, spot_direction) = light.view_projection_matrix(1.0, 0.1, global_transform.matrix);

        light_data.push(light
            .as_light(view_projection_matrix)
            .with_spot(global_transform.matrix.w_axis.xyz(), spot_direction)
        )
    }

    // point lights
    let mut point_query = query.cast::<(&GlobalTransform, &PointLight), ()>();
    for (global_transform, light) in point_query.iter_mut() {
        for i in 0..6 {
            let face = CubeFace::from_index(i);
            let view_projection_matrix = light.view_proj_matrix_for_face(global_transform.matrix, face);

            light_data.push(light
                .as_light(view_projection_matrix)
                .with_point(global_transform.matrix.w_axis.xyz())
            )
        }
    }

    // ambient light
    if let Some(light) = ctx.resources.get::<AmbientLight>() {
        light_data.push(light.as_light(Mat4::IDENTITY))
    };

    light_data
}

fn create_shadow_pipeline_builder(device: &wgpu::Device) -> PipelineBuilder {
    // Transform bind group layout for storage buffer
    let transforms_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("transforms_bind_group_layout"), 
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX,
                ty: wgpu::BindingType::Buffer { 
                    ty: wgpu::BufferBindingType::Storage { read_only: true },
                    has_dynamic_offset: false, 
                    min_binding_size: None 
                },
                count: None
            }
        ]
    });

    // Light bind group layout for storage buffer
    let lights_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("lights_bind_group_layout"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                ty: wgpu::BindingType::Buffer { 
                    ty: wgpu::BufferBindingType::Storage { read_only: true },
                    has_dynamic_offset: false,
                    min_binding_size: None
                },
                count: None
            },
        ]
    });

    // Create builder
    Pipeline::build("shadows_pipeline")
        .set_bind_group_layouts(vec![transforms_layout, lights_layout])
        .set_vertex_buffer_layouts(vec![Mesh::vertex_descriptor()])
        .set_vertex_shader(include_str!("../../shaders/shadow.wgsl"), "vs_main")
        .set_depth_format(wgpu::TextureFormat::Depth32Float)
        .set_push_constant_ranges(vec![wgpu::PushConstantRange {
            stages: wgpu::ShaderStages::VERTEX,
            range: 0..4,
        }])
}
