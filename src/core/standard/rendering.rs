use pipeline::PipelineBuilder;

use crate::{
    assets::ShaderLoader,
    core::{graph::*, lighting::LightAndShadowManager},
    prelude::*,
    render_assets::*,
    renderer::newtype::{
        RenderCommandEncoder, RenderDevice, RenderSurfaceConfiguration, RenderWindow,
    },
    system::CustomGraphSystem,
};

use super::grouped::GroupedInstances;

/// Creates a node for standard main render pass
pub fn standard_main_node(
    device: &RenderDevice,
    mut shader_loader: &mut ShaderLoader,
    surface_config: &RenderSurfaceConfiguration,
    window: &RenderWindow,
) -> GraphNode {
    // Create pipeline builder
    let main_pipeline_builder =
        create_main_pipeline_builder(&device, &mut shader_loader, &surface_config);

    // Create depth image
    let size = window.inner_size();
    let mut depth_image = Image::new_with_defaults(
        vec![],
        wgpu::Extent3d {
            width: size.width,
            height: size.height,
            depth_or_array_layers: 1,
        },
    );

    // Change defaults for depth image
    depth_image.texture_descriptor.as_mut().unwrap().format = wgpu::TextureFormat::Depth32Float;
    depth_image
        .texture_descriptor
        .as_mut()
        .unwrap()
        .view_formats = &[];
    depth_image.texture_descriptor.as_mut().unwrap().usage = wgpu::TextureUsages::RENDER_ATTACHMENT;
    depth_image.view_descriptor.as_mut().unwrap().format = Some(wgpu::TextureFormat::Depth32Float);

    GraphNodeBuilder::new("main")
        .set_pipeline(main_pipeline_builder)
        .set_custom_system(CustomGraphSystem::new(
            "main_render_system",
            main_render_system,
        ))
        .set_color_target(NodeColorTarget::Surface)
        .set_depth_target(NodeDepthTarget::Owned(depth_image))
        .build()
}

fn main_render_system(
    world: &mut World,
    encoder: &mut RenderCommandEncoder,
    mut buffers: ResMut<RenderAssets<Buffer>>,
    mut bind_groups: ResMut<RenderAssets<BindGroup>>,
    manager: Res<LightAndShadowManager>,
    grouped: Res<GroupedInstances>,
    transforms_storage: Res<TransformStorage>,

    mut camera_query: Query<
        (EntityId, &Camera),
        (With<Transform>, With<Projection>, With<Camera3D>),
    >,

    graph_ctx: CustomRenderGraphContext,
) {
    // Camera
    let (active_camera_id, active_camera) = match camera_query
        .iter_mut()
        .into_iter()
        .filter(|(_, c)| c.active)
        .take(1)
        .next()
    {
        Some(camera) => camera,
        None => return,
    };
    let camera_bind_group = bind_groups.get_by_entity(active_camera_id, active_camera, world);

    // Create render pass
    let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
        label: Some("main render pass"),
        color_attachments: &[Some(wgpu::RenderPassColorAttachment {
            view: unsafe { &*graph_ctx.color_target.expect("main color target is None") },
            depth_slice: None,
            resolve_target: None,
            ops: wgpu::Operations {
                load: wgpu::LoadOp::Clear(active_camera.clear_color.into()),
                store: wgpu::StoreOp::Store,
            },
        })],
        depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
            view: unsafe { &*graph_ctx.depth_target.expect("main depth target is None") },
            depth_ops: Some(wgpu::Operations {
                load: wgpu::LoadOp::Clear(1.0),
                store: wgpu::StoreOp::Store,
            }),
            stencil_ops: None,
        }),
        timestamp_writes: None,
        occlusion_query_set: None,
    });

    // Setup pipeline
    render_pass.set_pipeline(
        unsafe { &*graph_ctx.node }
            .data
            .pipeline
            .as_ref()
            .expect("Pipeline should have been generated by now")
            .render_pipeline(),
    );

    // Set light count push constant
    render_pass.set_push_constants(
        wgpu::ShaderStages::FRAGMENT,
        0,
        bytemuck::cast_slice(&[manager.storage.count() as u32]),
    );

    // TODO: currently we have to regen every time, because manager views got updated
    let manager_bind_group = bind_groups.get_by_resource(&manager, world, true);

    // Set bind groups
    render_pass.set_bind_group(1, transforms_storage.bind_group(), &[]);
    render_pass.set_bind_group(2, &*camera_bind_group, &[]);
    render_pass.set_bind_group(3, &*manager_bind_group, &[]);

    // Instanced draw loop
    let mut last_material = None;
    let mut last_mesh = None;
    // for (material, mesh, instance_count, instance_offset) in grouped {
    for group in &grouped.groups {
        let material = &group.material;
        let mesh = &group.mesh;
        let instance_count = group.instance_count;
        let instance_offset = group.instance_offset;

        // bind material
        if last_material != Some(material) {
            let material_bind_group = bind_groups.get_by_handle(material, world);
            render_pass.set_bind_group(0, &*material_bind_group, &[]);
            last_material = Some(material);
        }

        // set vertex buffer with mesh
        let mesh_buffer = buffers.get_by_handle(mesh, world);
        if last_mesh != Some(mesh) {
            let Some(vertex_buffer) = mesh_buffer.vertex.as_ref() else {
                continue;
            };

            render_pass.set_vertex_buffer(0, vertex_buffer.slice(..));
            last_mesh = Some(mesh);
        }

        // draw
        let instance_range = instance_offset..(instance_offset + instance_count);
        if let Some(index_buffer) = &mesh_buffer.index {
            render_pass.set_index_buffer(index_buffer.slice(..), wgpu::IndexFormat::Uint32);
            render_pass.draw_indexed(0..mesh_buffer.num_indices, 0, instance_range);
        } else {
            render_pass.draw(0..mesh_buffer.num_vertices, instance_range);
        }
    }
}

// TODO: add a better way to generate/get bind group layouts
fn create_main_pipeline_builder(
    device: &RenderDevice,
    shader_loader: &mut ShaderLoader,
    surface_config: &RenderSurfaceConfiguration,
) -> PipelineBuilder {
    // Material bind group layout for texture and uniform buffer
    let material_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("material_bind_group_layout"),
        entries: &[
            // base texture
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    view_dimension: wgpu::TextureViewDimension::D2,
                    multisampled: false,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
            // normal map
            wgpu::BindGroupLayoutEntry {
                binding: 2,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    view_dimension: wgpu::TextureViewDimension::D2,
                    multisampled: false,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 3,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
            // uniform buffer
            wgpu::BindGroupLayoutEntry {
                binding: 4,
                visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
        ],
    });

    // Transform bind group layout for storage buffer
    let transform_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("transform_bind_group_layout"),
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Storage { read_only: true },
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }],
    });

    // Camera bind group layout for uniform buffer
    let camera_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("camera_bind_group_layout"),
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }],
    });

    // Light and shadow manager
    let manager_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("light_and_shadow_manager_layout"),
        entries: &[
            // lights storage buffer
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Storage { read_only: true },
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            // directional shadow map
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    sample_type: wgpu::TextureSampleType::Depth,
                    view_dimension: wgpu::TextureViewDimension::D2Array,
                    multisampled: false,
                },
                count: None,
            },
            // point shadow map
            wgpu::BindGroupLayoutEntry {
                binding: 2,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    sample_type: wgpu::TextureSampleType::Depth,
                    view_dimension: wgpu::TextureViewDimension::CubeArray,
                    multisampled: false,
                },
                count: None,
            },
            // spot shadow map
            wgpu::BindGroupLayoutEntry {
                binding: 3,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    sample_type: wgpu::TextureSampleType::Depth,
                    view_dimension: wgpu::TextureViewDimension::D2Array,
                    multisampled: false,
                },
                count: None,
            },
            // shadow map sampler
            wgpu::BindGroupLayoutEntry {
                binding: 4,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Comparison),
                count: None,
            },
        ],
    });

    // Load shader modules
    shader_loader
        .load("main", include_str!("../../shaders/shader.wgsl"), device)
        .expect("Shader with label 'main' already exists");

    // Create builder
    Pipeline::build("main_pipeline")
        .set_bind_group_layouts(vec![
            material_layout,
            transform_layout,
            camera_layout,
            manager_layout,
        ])
        .set_vertex_buffer_layouts(vec![Mesh::vertex_descriptor()])
        .set_vertex_shader("main", "vs_main")
        .set_fragment_shader("main", "fs_main")
        .add_color_format(surface_config.format)
        .set_depth_format(wgpu::TextureFormat::Depth32Float)
        .set_push_constant_ranges(vec![wgpu::PushConstantRange {
            stages: wgpu::ShaderStages::FRAGMENT,
            range: 0..4,
        }])
}
